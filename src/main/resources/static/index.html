<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DOK Editor</title>
    <!-- Toast UI Editor's CSS -->
    <link rel="stylesheet" href="https://uicdn.toast.com/editor/latest/toastui-editor.min.css" />
    <style>
        /* --- Layout Restoration --- */
        html, body {
            height: 100vh; /* Use viewport height */
            margin: 0;
            font-family: sans-serif;
            overflow: hidden; /* Prevent top-level scrollbars */
        }
        body {
            display: flex;
            flex-direction: row;
        }
        #file-browser {
            flex: 0 0 250px; /* Don't grow, don't shrink, start at 250px */
            min-width: 200px; /* But don't get smaller than this */
            padding: 10px;
            border-right: 1px solid #ccc;
            overflow-y: auto;
            resize: horizontal; /* Allow user to resize the file browser! */
        }
        #main-content {
            flex: 1 1 auto; /* Grow to fill remaining space */
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Hide overflow to prevent scrollbars */
        }
        #controls {
            flex-shrink: 0; /* Don't shrink the controls bar */
            padding: 10px;
            border-bottom: 1px solid #ccc;
            display: flex;
            align-items: center;
        }
        #editor-wrapper {
            flex-grow: 1; /* Make the editor wrapper fill vertical space */
            height: 100%;
            overflow: hidden;
        }
        /* --- TUI Editor Overrides --- */
        .toastui-editor-defaultUI {
            border: none !important;
            height: 100% !important;
        }
        .toastui-editor-toolbar {
            display: none !important; /* Hide toolbar for a cleaner look */
        }
        .toastui-editor-main-container {
            height: 100% !important;
        }

        /* --- Other Styles (Unchanged) --- */
        ul { list-style-type: none; padding-left: 15px; }
        li > span { cursor: pointer; display: block; padding: 2px 0; border-radius: 3px; }
        .folder { font-weight: bold; }
        .selected { background-color: #d4e8ff; }
        #filePath { flex-grow: 1; border: none; background: #f0f0f0; padding: 5px; }
        #file-browser-controls { padding-bottom: 10px; border-bottom: 1px solid #ccc; margin-bottom: 10px; }
        .drop-target { background-color: #c8e6c9; }
    </style>
</head>
<body>

<div id="file-browser">
    <h3>Project Files</h3>
    <div id="file-browser-controls">
        <button onclick="createFile()">New File</button>
        <button onclick="createDirectory()">New Directory</button>
    </div>
    <div id="file-tree"></div>
</div>

<div id="main-content">
    <div id="controls">
        <input type="text" id="filePath" placeholder="Select a file from the browser..." readonly>
    </div>
    <div id="editor-wrapper"></div>
</div>

<!-- Toast UI Editor's JavaScript -->
<script src="https://uicdn.toast.com/editor/latest/toastui-editor-all.min.js"></script>
<script>
    // All JavaScript functionality from the previous version remains unchanged.
    // I am only fixing the CSS layout as requested.

    const filePathInput = document.getElementById('filePath');
    const fileTreeDiv = document.getElementById('file-tree');
    const editorWrapper = document.getElementById('editor-wrapper');

    let editor = null;
    let currentOpenFile = null;
    let selectedPathForCreation = '/';
    let fileIndex = {}; // For wikilink resolution
    let isSaving = false; // Flag to prevent re-triggering change event during save

    // --- UTILITY FUNCTIONS ---
    
    function debounce(func, delay) {
        let timeout;
        return function(...args) {
            const context = this;
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(context, args), delay);
        };
    }

    // --- Wikilink and File Indexing ---
    
    async function buildFileIndex(path = '/') {
        try {
            const response = await fetch(`/list?path=${encodeURIComponent(path)}`);
            const files = await response.json();
            for (const file of files) {
                if (file.isDirectory) {
                    await buildFileIndex(file.path);
                } else {
                    const nameWithoutExt = file.name.endsWith('.md') ? file.name.slice(0, -3) : file.name;
                    fileIndex[nameWithoutExt] = file.path;
                    fileIndex[file.name] = file.path; // Also index with extension
                }
            }
        } catch (error) {
            console.error('Failed to build file index:', error);
        }
    }

    function handleEditorLinkClick(event) {
        const target = event.target.closest('a');
        if (target) {
            const href = target.getAttribute('href');
            if (href && !href.startsWith('http') && !href.startsWith('#') && !href.startsWith('/')) {
                event.preventDefault();
                const decodedHref = decodeURIComponent(href);
                const path = fileIndex[decodedHref] || fileIndex[target.textContent];

                if (path) {
                    const targetSpan = document.querySelector(`span[data-path='${path}']`);
                    loadFile(path, targetSpan);
                } else {
                    alert(`File for link "${target.textContent}" not found.`);
                }
            }
        }
    }

    // --- Drag and Drop Handlers (Unchanged) ---
    
    function handleDragStart(e) {
        e.dataTransfer.setData('text/plain', e.target.dataset.path);
        e.dataTransfer.effectAllowed = 'move';
    }

    function handleDragOver(e) {
        e.preventDefault();
        e.currentTarget.classList.add('drop-target');
    }

    function handleDragLeave(e) {
        e.currentTarget.classList.remove('drop-target');
    }

    function handleDrop(e) {
        e.preventDefault();
        e.stopPropagation();
        e.currentTarget.classList.remove('drop-target');

        const sourcePath = e.dataTransfer.getData('text/plain');
        const listenerElement = e.currentTarget;

        let destinationPath = null;
        if (listenerElement.classList.contains('folder')) {
            destinationPath = listenerElement.dataset.path;
        } else if (listenerElement.id === 'file-tree') {
            destinationPath = '/';
        }

        if (destinationPath === null) return;
        if (sourcePath === destinationPath || (destinationPath !== '/' && destinationPath.startsWith(sourcePath + '/'))) {
            alert("Cannot move a directory into itself or one of its children.");
            return;
        }
        moveItem(sourcePath, destinationPath);
    }

    async function moveItem(source, destination) {
        try {
            const response = await fetch('/move', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: `source=${encodeURIComponent(source)}&destination=${encodeURIComponent(destination)}`
            });
            if (response.ok) {
                alert(await response.text());
                fetchAndDisplayTree();
            } else {
                alert('Error moving item: ' + await response.text());
            }
        } catch (error) {
            alert('An error occurred during move: ' + error.message);
        }
    }

    // --- File Tree and Selection (Unchanged) ---
    
    function updateSelection(element, path) {
        document.querySelectorAll('#file-tree span').forEach(s => s.classList.remove('selected'));
        if (element) {
            element.classList.add('selected');
        }
        selectedPathForCreation = path;
    }

    async function fetchAndDisplayTree(path = '/', element = fileTreeDiv) {
        try {
            const response = await fetch(`/list?path=${encodeURIComponent(path)}`);
            const files = await response.json();
            files.sort((a, b) => {
                if (a.isDirectory !== b.isDirectory) return a.isDirectory ? -1 : 1;
                return a.name.localeCompare(b.name);
            });
            
            const ul = document.createElement('ul');
            for (const file of files) {
                const li = document.createElement('li');
                const span = document.createElement('span');
                span.textContent = file.name;
                span.dataset.path = file.path;
                span.draggable = true;
                span.addEventListener('dragstart', handleDragStart);

                if (file.isDirectory) {
                    span.classList.add('folder');
                    span.addEventListener('dragover', handleDragOver);
                    span.addEventListener('dragleave', handleDragLeave);
                    span.addEventListener('drop', handleDrop);
                    span.onclick = (event) => {
                        event.stopPropagation();
                        updateSelection(span, file.path);
                        const nestedUl = li.querySelector('ul');
                        if (nestedUl) {
                            nestedUl.remove();
                        } else {
                            fetchAndDisplayTree(file.path, li);
                        }
                    };
                } else {
                    span.onclick = (event) => {
                        event.stopPropagation();
                        loadFile(file.path, span);
                    };
                }
                li.appendChild(span);
                ul.appendChild(li);
            }

            if (element === fileTreeDiv) {
                element.innerHTML = '';
                element.appendChild(ul);
            } else {
                element.appendChild(ul);
            }
        } catch (error) {
            console.error('Error fetching file tree:', error);
        }
    }

    // --- File Operations ---
    
    async function loadFile(path, element) {
        if (!path || !editor) return;

        currentOpenFile = path;
        filePathInput.value = path;
        updateSelection(element, path);

        editor.setMarkdown('Loading...', false);

        try {
            const rawResponse = await fetch(`/raw?path=${encodeURIComponent(path)}`);
            if (!rawResponse.ok) throw new Error(`Server responded with ${rawResponse.status}`);
            const rawContent = await rawResponse.text();
            
            isSaving = true; // Prevent change event from firing on load
            editor.setMarkdown(rawContent, false);
            isSaving = false;

        } catch (error) {
            const errorMessage = `Error loading file: ${error.message}`;
            isSaving = true;
            editor.setMarkdown(errorMessage, false);
            isSaving = false;
            currentOpenFile = null;
        }
    }

    async function autoSave() {
        if (!currentOpenFile || !editor || isSaving) {
            return;
        }
        isSaving = true;
        try {
            const fileContent = editor.getMarkdown();

            const response = await fetch('/save', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: `path=${encodeURIComponent(currentOpenFile)}&content=${encodeURIComponent(fileContent)}`
            });
            if (!response.ok) {
                console.error('Error auto-saving file:', await response.text());
            }
        } catch (error) {
            console.error('An error occurred during auto-save:', error.message);
        } finally {
            isSaving = false;
        }
    }

    async function createItem(type) {
        const name = prompt(`Enter the name for the new ${type}:`);
        if (!name || name.includes('/')) {
            if(name) alert("Name cannot contain a slash.");
            return;
        }

        let parentPath = '/';
        const selectedSpan = document.querySelector('.selected');
        if (selectedPathForCreation) {
            if (selectedSpan && selectedSpan.classList.contains('folder')) {
                parentPath = selectedPathForCreation;
            } else if (selectedPathForCreation !== '/') {
                parentPath = selectedPathForCreation.substring(0, selectedPathForCreation.lastIndexOf('/')) || '/';
            }
        }

        const newPath = (parentPath === '/' ? '' : parentPath) + '/' + name;
        const endpoint = type === 'file' ? '/create-file' : '/create-directory';

        try {
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: `path=${encodeURIComponent(newPath)}`
            });

            if (response.ok) {
                alert(`${type} created successfully!`);
                await buildFileIndex(); // Re-index
                await fetchAndDisplayTree(); // Full refresh to show new item

                if (type === 'file') {
                    setTimeout(() => {
                        const newFileSpan = document.querySelector(`span[data-path='${newPath}']`);
                        if (newFileSpan) {
                            loadFile(newPath, newFileSpan);
                        }
                    }, 300);
                }
            } else {
                alert(`Error creating ${type}: ` + await response.text());
            }
        } catch (error) {
            alert(`An error occurred: ` + error.message);
        }
    }

    function createFile() { createItem('file'); }
    function createDirectory() { createItem('directory'); }

    // --- INITIALIZATION ---
    
    document.addEventListener('DOMContentLoaded', async () => {
        editor = new toastui.Editor({
            el: editorWrapper,
            initialEditType: 'markdown', // The user still sees tabs, this will be fixed next
            previewStyle: 'vertical',    // But the default is side-by-side
            height: '100%',
            usageStatistics: false,
            events: {
                change: debounce(autoSave, 500)
            }
        });

        // Add event listeners
        fileTreeDiv.addEventListener('dragover', handleDragOver);
        fileTreeDiv.addEventListener('dragleave', handleDragLeave);
        fileTreeDiv.addEventListener('drop', handleDrop);
        editorWrapper.addEventListener('click', handleEditorLinkClick);

        console.log('Building file index...');
        await buildFileIndex();
        console.log('File index built.');
        
        await fetchAndDisplayTree();
    });
</script>
</body>
</html>