<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Markdown Editor</title>
    <style>
        body { font-family: sans-serif; display: flex; height: 100vh; margin: 0; }
        #file-browser { width: 25%; border-right: 1px solid #ccc; padding: 10px; overflow-y: auto; }
        #main-content { width: 75%; display: flex; flex-direction: column; }
        #controls { padding: 10px; border-bottom: 1px solid #ccc; display: flex; align-items: center; }
        #file-browser-controls { padding-bottom: 10px; border-bottom: 1px solid #ccc; margin-bottom: 10px; }
        #editor-container { display: flex; flex-grow: 1; height: calc(100vh - 50px); }
        #editor, #preview { width: 50%; padding: 10px; box-sizing: border-box; overflow-y: auto; height: 100%; }
        #editor { border-right: 1px solid #ccc; }
        textarea { width: 100%; height: 100%; border: none; resize: none; outline: none; }
        ul { list-style-type: none; padding-left: 15px; }
        li > span { cursor: pointer; display: block; padding: 2px 0; border-radius: 3px; }
        .folder { font-weight: bold; }
        .selected { background-color: #d4e8ff; }
        #filePath { flex-grow: 1; border: none; background: #f0f0f0; padding: 5px; }
        .drop-target { background-color: #c8e6c9; } /* Visual feedback for drop target */
        #preview a { color: #0366d6; text-decoration: none; }
        #preview a:hover { text-decoration: underline; }
    </style>
</head>
<body>

<div id="file-browser">
    <h3>Project Files</h3>
    <div id="file-browser-controls">
        <button onclick="createFile()">New File</button>
        <button onclick="createDirectory()">New Directory</button>
    </div>
    <div id="file-tree"></div>
</div>

<div id="main-content">
    <div id="controls">
        <input type="text" id="filePath" placeholder="Select a file from the browser..." readonly>
        <button onclick="saveFile()">Save</button>
    </div>
    <div id="editor-container">
        <div id="editor">
            <textarea id="markdown" placeholder="Select a file to start editing..."></textarea>
        </div>
        <div id="preview"></div>
    </div>
</div>

<script>
    const filePathInput = document.getElementById('filePath');
    const markdownTextarea = document.getElementById('markdown');
    const previewDiv = document.getElementById('preview');
    const fileTreeDiv = document.getElementById('file-tree');

    let currentOpenFile = null;
    let selectedPathForCreation = '/';
    let fileIndex = {}; // For wikilink resolution

    // --- Wikilink and File Indexing ---
    async function buildFileIndex(path = '/') {
        try {
            const response = await fetch(`/list?path=${encodeURIComponent(path)}`);
            const files = await response.json();
            for (const file of files) {
                if (file.isDirectory) {
                    await buildFileIndex(file.path);
                } else {
                    const nameWithoutExt = file.name.endsWith('.md') ? file.name.slice(0, -3) : file.name;
                    fileIndex[nameWithoutExt] = file.path;
                    fileIndex[file.name] = file.path; // Also index with extension
                }
            }
        } catch (error) {
            console.error('Failed to build file index:', error);
        }
    }

    function handlePreviewClick(event) {
        const target = event.target.closest('a');
        if (target) {
            const href = target.getAttribute('href');
            // Check if it's a wikilink (relative path, not a hash link or absolute URL)
            if (href && !href.startsWith('http') && !href.startsWith('#') && !href.startsWith('/')) {
                event.preventDefault();
                const decodedHref = decodeURIComponent(href);
                const path = fileIndex[decodedHref] || fileIndex[target.textContent];

                if (path) {
                    const targetSpan = document.querySelector(`span[data-path='${path}']`);
                    loadFile(path, targetSpan);
                } else {
                    alert(`File for link "${target.textContent}" not found.`);
                }
            }
        }
    }

    // --- Drag and Drop Handlers ---
    function handleDragStart(e) {
        e.dataTransfer.setData('text/plain', e.target.dataset.path);
        e.dataTransfer.effectAllowed = 'move';
    }

    function handleDragOver(e) {
        e.preventDefault();
        e.currentTarget.classList.add('drop-target');
    }

    function handleDragLeave(e) {
        e.currentTarget.classList.remove('drop-target');
    }

    function handleDrop(e) {
        e.preventDefault();
        e.stopPropagation();
        e.currentTarget.classList.remove('drop-target');

        const sourcePath = e.dataTransfer.getData('text/plain');
        const listenerElement = e.currentTarget;

        let destinationPath = null;
        if (listenerElement.classList.contains('folder')) {
            destinationPath = listenerElement.dataset.path;
        } else if (listenerElement.id === 'file-tree') {
            destinationPath = '/';
        }

        if (destinationPath === null) return;
        if (sourcePath === destinationPath || (destinationPath !== '/' && destinationPath.startsWith(sourcePath + '/'))) {
            alert("Cannot move a directory into itself or one of its children.");
            return;
        }
        moveItem(sourcePath, destinationPath);
    }

    async function moveItem(source, destination) {
        try {
            const response = await fetch('/move', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: `source=${encodeURIComponent(source)}&destination=${encodeURIComponent(destination)}`
            });
            if (response.ok) {
                alert(await response.text());
                fetchAndDisplayTree();
            } else {
                alert('Error moving item: ' + await response.text());
            }
        } catch (error) {
            alert('An error occurred during move: ' + error.message);
        }
    }

    function updateSelection(element, path) {
        document.querySelectorAll('#file-tree span').forEach(s => s.classList.remove('selected'));
        if (element) {
            element.classList.add('selected');
        }
        selectedPathForCreation = path;
    }

    async function loadFile(path, element) {
        if (!path) return;

        currentOpenFile = path;
        filePathInput.value = path;
        updateSelection(element, path);

        markdownTextarea.value = 'Loading...';
        previewDiv.innerHTML = 'Loading...';

        try {
            const rawResponse = await fetch(`/raw?path=${encodeURIComponent(path)}`);
            if (!rawResponse.ok) throw new Error(`Server responded with ${rawResponse.status} when fetching raw content.`);
            markdownTextarea.value = await rawResponse.text();

            const renderedResponse = await fetch(`/view?path=${encodeURIComponent(path)}`);
            if (!renderedResponse.ok) throw new Error(`Server responded with ${renderedResponse.status} when fetching rendered view.`);
            previewDiv.innerHTML = await renderedResponse.text();

        } catch (error) {
            const errorMessage = `Error loading file: ${error.message}`;
            previewDiv.innerHTML = `<p style="color: red;">${errorMessage}</p>`;
            markdownTextarea.value = errorMessage;
            currentOpenFile = null;
        }
    }

    async function saveFile() {
        if (!currentOpenFile) {
            alert('No file is currently open. Please select a file to save.');
            return;
        }
        try {
            const response = await fetch('/save', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: `path=${encodeURIComponent(currentOpenFile)}&content=${encodeURIComponent(markdownTextarea.value)}`
            });
            if (response.ok) {
                alert('File saved successfully!');
                const renderedResponse = await fetch(`/view?path=${encodeURIComponent(currentOpenFile)}`);
                previewDiv.innerHTML = await renderedResponse.text();
            } else {
                alert('Error saving file: ' + await response.text());
            }
        } catch (error) {
            alert('An error occurred during save: ' + error.message);
        }
    }

    async function fetchAndDisplayTree(path = '/', element = fileTreeDiv) {
        try {
            const response = await fetch(`/list?path=${encodeURIComponent(path)}`);
            const files = await response.json();
            files.sort((a, b) => {
                if (a.isDirectory !== b.isDirectory) return a.isDirectory ? -1 : 1;
                return a.name.localeCompare(b.name);
            });
            
            const ul = document.createElement('ul');
            for (const file of files) {
                const li = document.createElement('li');
                const span = document.createElement('span');
                span.textContent = file.name;
                span.dataset.path = file.path;
                span.draggable = true;
                span.addEventListener('dragstart', handleDragStart);

                if (file.isDirectory) {
                    span.classList.add('folder');
                    span.addEventListener('dragover', handleDragOver);
                    span.addEventListener('dragleave', handleDragLeave);
                    span.addEventListener('drop', handleDrop);
                    span.onclick = (event) => {
                        event.stopPropagation();
                        updateSelection(span, file.path);
                        const nestedUl = li.querySelector('ul');
                        if (nestedUl) {
                            nestedUl.remove();
                        } else {
                            fetchAndDisplayTree(file.path, li);
                        }
                    };
                } else {
                    span.onclick = (event) => {
                        event.stopPropagation();
                        loadFile(file.path, span);
                    };
                }
                li.appendChild(span);
                ul.appendChild(li);
            }

            if (element === fileTreeDiv) {
                element.innerHTML = '';
                element.appendChild(ul);
            } else {
                element.appendChild(ul);
            }
        } catch (error) {
            console.error('Error fetching file tree:', error);
        }
    }
    
    async function createItem(type) {
        const name = prompt(`Enter the name for the new ${type}:`);
        if (!name || name.includes('/')) {
            if(name) alert("Name cannot contain a slash.");
            return;
        }

        let parentPath = '/';
        const selectedSpan = document.querySelector('.selected');
        if (selectedPathForCreation) {
            if (selectedSpan && selectedSpan.classList.contains('folder')) {
                parentPath = selectedPathForCreation;
            } else if (selectedPathForCreation !== '/') {
                parentPath = selectedPathForCreation.substring(0, selectedPathForCreation.lastIndexOf('/')) || '/';
            }
        }

        const newPath = (parentPath === '/' ? '' : parentPath) + '/' + name;
        const endpoint = type === 'file' ? '/create-file' : '/create-directory';

        try {
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: `path=${encodeURIComponent(newPath)}`
            });

            if (response.ok) {
                alert(`${type} created successfully!`);
                await buildFileIndex(); // Re-index everything on creation
                let parentElementToRefresh;
                if (parentPath === '/') {
                    await fetchAndDisplayTree('/');
                } else {
                    const parentSpan = document.querySelector(`span[data-path='${parentPath}']`);
                    parentElementToRefresh = parentSpan ? parentSpan.parentElement : fileTreeDiv;
                    const nestedUl = parentElementToRefresh.querySelector('ul');
                    if (nestedUl) nestedUl.remove();
                    await fetchAndDisplayTree(parentPath, parentElementToRefresh);
                }

                if (type === 'file') {
                    setTimeout(() => {
                        const newFileSpan = document.querySelector(`span[data-path='${newPath}']`);
                        if (newFileSpan) {
                            loadFile(newPath, newFileSpan);
                        }
                    }, 300);
                }
            } else {
                alert(`Error creating ${type}: ` + await response.text());
            }
        } catch (error) {
            alert(`An error occurred: ` + error.message);
        }
    }

    function createFile() { createItem('file'); }
    function createDirectory() { createItem('directory'); }

    document.addEventListener('DOMContentLoaded', async () => {
        fileTreeDiv.addEventListener('dragover', handleDragOver);
        fileTreeDiv.addEventListener('dragleave', handleDragLeave);
        fileTreeDiv.addEventListener('drop', handleDrop);
        previewDiv.addEventListener('click', handlePreviewClick);
        
        console.log('Building file index...');
        await buildFileIndex();
        console.log('File index built.');
        
        await fetchAndDisplayTree();
    });
</script>
</body>
</html>